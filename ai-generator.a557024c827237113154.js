(self.webpackChunklorcana_deck_generator=self.webpackChunklorcana_deck_generator||[]).push([[745],{580:(e,t,s)=>{"use strict";var a=s(947),n=s(122);class o{constructor(){this.model=null,this.vocabSize=0,this.featureDim=0,this.maxLen=60,this.embeddingDim=32,this.lstmUnits=64,this.textVocabSize=0,this.maxTextTokens=0,this.textEmbeddingDim=16}async initialize(e,t,s,a,o,i,r,l,d){this.vocabSize=e+1,this.featureDim=t,this.textVocabSize=s,this.maxNameTokens=a,this.maxKeywordsTokens=o,this.maxInkTokens=i,this.maxClassTokens=r,this.maxTypeTokens=l,this.maxBodyTokens=d;const h=n.hFB({shape:[this.maxLen,this.featureDim],dtype:"float32",name:"input_features"}),c=n.hFB({shape:[this.maxLen,this.maxNameTokens],dtype:"int32",name:"input_name_tokens"}),m=n.hFB({shape:[this.maxLen,this.maxKeywordsTokens],dtype:"int32",name:"input_keywords_tokens"}),u=n.hFB({shape:[this.maxLen,this.maxInkTokens],dtype:"int32",name:"input_ink_tokens"}),p=n.hFB({shape:[this.maxLen,this.maxClassTokens],dtype:"int32",name:"input_class_tokens"}),k=n.hFB({shape:[this.maxLen,this.maxTypeTokens],dtype:"int32",name:"input_type_tokens"}),y=n.hFB({shape:[this.maxLen,this.maxBodyTokens],dtype:"int32",name:"input_body_tokens"}),g=n.ZFI.embedding({inputDim:this.textVocabSize,outputDim:this.textEmbeddingDim,name:"shared_text_embedding"}),f=(e,t,s,a)=>{const o=g.apply(e),i=n.ZFI.reshape({targetShape:[this.maxLen,t*this.textEmbeddingDim],name:`${s}_flatten`}).apply(o);return n.ZFI.dense({units:a,activation:"relu",name:`${s}_projection`}).apply(i)},x=f(c,this.maxNameTokens,"name",8),T=f(m,this.maxKeywordsTokens,"keywords",12),v=f(u,this.maxInkTokens,"ink",4),w=f(p,this.maxClassTokens,"class",8),b=f(k,this.maxTypeTokens,"type",4),C=f(y,this.maxBodyTokens,"body",24),M=n.ZFI.concatenate({name:"concat_all_features"}).apply([h,x,T,v,w,b,C]),A=n.ZFI.lstm({units:this.lstmUnits,returnSequences:!1,name:"lstm"}).apply(M),L=n.ZFI.dense({units:this.vocabSize,activation:"softmax",name:"output"}).apply(A);this.model=n.geq({inputs:[h,c,m,u,p,k,y],outputs:L,name:"deck_predictor"}),this.model.compile({optimizer:n.BaG.adam(.001),loss:"sparseCategoricalCrossentropy",metrics:["accuracy"]}),this.model.summary()}async train(e,t,s,a,n){console.warn("Training in frontend is not fully implemented/optimized.")}prepareData(e,t){return{}}async predict(e,t,s){if(!this.model)return null;const a=Math.max(0,this.maxLen-e.length),o=[];for(let e=0;e<this.maxLen;e++)o.push(Array(this.featureDim).fill(0));for(let e=0;e<Math.min(t.length,this.maxLen);e++)o[a+e]=t[e];!this.maxNameTokens&&this.model.inputs.length>1&&(this.maxNameTokens=this.model.inputs[1].shape[2],this.maxKeywordsTokens=this.model.inputs[2].shape[2],this.maxInkTokens=this.model.inputs[3].shape[2],this.maxClassTokens=this.model.inputs[4].shape[2],this.maxTypeTokens=this.model.inputs[5].shape[2],this.maxBodyTokens=this.model.inputs[6].shape[2]);const i=[],r=[],l=[],d=[],h=[],c=[];for(let e=0;e<this.maxLen;e++)i.push(Array(this.maxNameTokens).fill(0)),r.push(Array(this.maxKeywordsTokens).fill(0)),l.push(Array(this.maxInkTokens).fill(0)),d.push(Array(this.maxClassTokens).fill(0)),h.push(Array(this.maxTypeTokens).fill(0)),c.push(Array(this.maxBodyTokens).fill(0));if(s)for(let e=0;e<Math.min(s.length,this.maxLen);e++){const t=s[e],n=(e,t)=>{const s=e.slice(0,t);return s.concat(Array(t-s.length).fill(0))};i[a+e]=n(t.name,this.maxNameTokens),r[a+e]=n(t.keywords,this.maxKeywordsTokens),l[a+e]=n(t.ink,this.maxInkTokens),d[a+e]=n(t.classifications,this.maxClassTokens),h[a+e]=n(t.types,this.maxTypeTokens),c[a+e]=n(t.text,this.maxBodyTokens)}const m=n.$_$([o],[1,this.maxLen,this.featureDim]),u=n.$_$([i],[1,this.maxLen,this.maxNameTokens]),p=n.$_$([r],[1,this.maxLen,this.maxKeywordsTokens]),k=n.$_$([l],[1,this.maxLen,this.maxInkTokens]),y=n.$_$([d],[1,this.maxLen,this.maxClassTokens]),g=n.$_$([h],[1,this.maxLen,this.maxTypeTokens]),f=n.$_$([c],[1,this.maxLen,this.maxBodyTokens]),x=this.model.predict([m,u,p,k,y,g,f]),T=await x.data();return m.dispose(),u.dispose(),p.dispose(),k.dispose(),y.dispose(),g.dispose(),f.dispose(),x.dispose(),T}async saveModel(e){this.model&&(e.startsWith("file://")||(e=`file://${e}`),await this.model.save(e))}async loadModel(e){this.model=await n.O0W(e),this.model.compile({optimizer:"adam",loss:"sparseCategoricalCrossentropy",metrics:["accuracy"]}),this.model.inputs&&this.model.inputs.length>0&&(this.featureDim=this.model.inputs[0].shape[2]),this.model.inputs&&this.model.inputs.length>1&&(this.maxNameTokens=this.model.inputs[1].shape[2]),this.model.inputs&&this.model.inputs.length>2&&(this.maxKeywordsTokens=this.model.inputs[2].shape[2]),this.model.inputs&&this.model.inputs.length>3&&(this.maxInkTokens=this.model.inputs[3].shape[2]),this.model.inputs&&this.model.inputs.length>4&&(this.maxClassTokens=this.model.inputs[4].shape[2]),this.model.inputs&&this.model.inputs.length>5&&(this.maxTypeTokens=this.model.inputs[5].shape[2]),this.model.inputs&&this.model.inputs.length>6&&(this.maxBodyTokens=this.model.inputs[6].shape[2]),this.model.summary()}}class i{constructor(){this.tokenToIndex={"<PAD>":0,"<UNK>":1},this.indexToToken={0:"<PAD>",1:"<UNK>"},this.vocabularySize=2,this.maxNameTokens=5,this.maxKeywordsTokens=10,this.maxInkTokens=2,this.maxClassTokens=5,this.maxTypeTokens=3,this.maxBodyTokens=30,this.allCardNames=[]}load(e){this.tokenToIndex=e.tokenToIndex,this.indexToToken=e.indexToToken,this.vocabularySize=e.vocabularySize,this.maxNameTokens=e.maxNameTokens||5,this.maxKeywordsTokens=e.maxKeywordsTokens||10,this.maxInkTokens=e.maxInkTokens||2,this.maxClassTokens=e.maxClassTokens||5,this.maxTypeTokens=e.maxTypeTokens||3,this.maxBodyTokens=e.maxBodyTokens||30,this.allCardNames=e.allCardNames||[],console.log(`Vocabulary loaded (${this.vocabularySize} tokens)`)}cleanText(e){if(!e)return"";let t=e.toLowerCase();return t=t.replace(/\{e\}/g," exert "),t=t.replace(/[^a-z0-9\s+\{\}]/g,""),t.trim()}extractTextTokens(e,t){const s=[];let a=this.cleanText(e);t.forEach((e=>{a.includes(e)&&(s.push(e),a=a.replace(new RegExp(e,"g")," "))}));const n=a.split(/\s+/).map((e=>e.trim())).filter((e=>e.length>2||"+"===e||"{"===e||"}"===e));return s.push(...n),s}cardToTextIndices(e){const t=[],s=this.cleanText(e.name);s&&(void 0!==this.tokenToIndex[s]?t.push(this.tokenToIndex[s]):t.push(this.tokenToIndex["<UNK>"]));const a=[];e.keywords&&Array.isArray(e.keywords)&&e.keywords.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];a.push(s)}));const n=[];if(e.ink){const t=this.cleanText(e.ink),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];n.push(s)}const o=[];e.classifications&&Array.isArray(e.classifications)&&e.classifications.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];o.push(s)}));const i=[];e.types&&Array.isArray(e.types)?e.types.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];i.push(s)})):e.type&&Array.isArray(e.type)&&e.type.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];i.push(s)}));const r=[];let l=e.sanitizedText;return!l&&e.text&&(l=e.text.toLowerCase().replace(/\([^)]+\)/g,"").replace(/\(|\)/g,"").trim()),l&&this.extractTextTokens(l,this.allCardNames).forEach((e=>{const t=this.tokenToIndex[e]||this.tokenToIndex["<UNK>"];r.push(t)})),{name:this.padOrTruncate(t,this.maxNameTokens),keywords:this.padOrTruncate(a,this.maxKeywordsTokens),ink:this.padOrTruncate(n,this.maxInkTokens),classifications:this.padOrTruncate(o,this.maxClassTokens),types:this.padOrTruncate(i,this.maxTypeTokens),text:this.padOrTruncate(r,this.maxBodyTokens)}}padOrTruncate(e,t){if(e.length>=t)return e.slice(0,t);const s=[...e];for(;s.length<t;)s.push(0);return s}}class r{constructor(){this.model=null,this.featureDim=0,this.thresholds={excellent:.85,good:.7,fair:.5,poor:0}}async loadModel(e){this.model=await n.O0W(e),this.model.compile({optimizer:"adam",loss:"binaryCrossentropy",metrics:["accuracy"]}),this.model.inputs&&this.model.inputs.length>0&&(this.featureDim=this.model.inputs[0].shape[1]),console.log("Validation model loaded successfully")}async evaluate(e){if(!this.model)return null;const t=e[0],s=Math.round(20*t);if(s<10)return console.log(`[RULE] Low diversity detected: ${s} unique cards - returning 0.0`),0;const a=n.KtR([e]),o=this.model.predict(a),i=(await o.data())[0];return a.dispose(),o.dispose(),i}async evaluateWithBreakdown(e){const t=await this.evaluate(e),s=this.analyzeFeatures(e);return{score:t,grade:this.getGrade(t),message:this.getMessage(t),breakdown:s}}analyzeFeatures(e){const t=[],s=e[0],a=Math.round(20*s);a<10?t.push({issue:"Very low card diversity",severity:"high",message:`Only ~${a} unique cards (expected 15-20)`}):a>25&&t.push({issue:"Too many unique cards",severity:"medium",message:`~${a} unique cards (expected 15-20)`});const n=e[1];n>.3&&t.push({issue:"High singleton count",severity:"high",message:`${Math.round(100*n)}% of unique cards have only 1 copy`});const o=e.slice(6,16);this.calculateVariance(o)<.005&&t.push({issue:"Flat mana curve",severity:"medium",message:"Mana curve is too uniform (expected bell curve)"});const i=e[26];i<.5&&t.push({issue:"Low inkable ratio",severity:"medium",message:`Only ${Math.round(100*i)}% inkable cards (recommended at least 50%)`});const r=e[16];return r<.3&&t.push({issue:"Low character count",severity:"high",message:`Only ${Math.round(100*r)}% characters`}),e[37]<.1&&t.push({issue:"Low synergy",severity:"medium",message:"Cards appear to lack thematic cohesion"}),t}calculateVariance(e){const t=e.reduce(((e,t)=>e+t),0)/e.length;return e.map((e=>Math.pow(e-t,2))).reduce(((e,t)=>e+t),0)/e.length}getGrade(e){return e>=this.thresholds.excellent?"A":e>=this.thresholds.good?"B":e>=this.thresholds.fair?"C":"D"}getMessage(e){return e>=this.thresholds.excellent?"This deck looks authentic!":e>=this.thresholds.good?"This deck looks realistic with minor issues":e>=this.thresholds.fair?"This deck has some unrealistic patterns":"This deck seems randomly generated"}}class l{constructor(){this.cardApi=new a.A,this.model=new o,this.textEmbedder=new i,this.validationModel=new r,this.validationModelLoaded=!1,this.cards=[],this.cardMap=new Map,this.indexMap=new Map}getCardKey(e,t){return t?`${e} - ${t}`:e}async loadCards(){return 0===this.cards.length&&(this.cards=await this.cardApi.getCards(),this.cards.forEach((e=>{const t=this.getCardKey(e.name,e.version);if(!this.cardMap.has(t)){const s=this.cardMap.size;this.cardMap.set(t,s),this.indexMap.set(s,e)}}))),this.cards}async loadModel(e){await this.loadCards();try{const e=await fetch("training_data/vocabulary.json");if(e.ok){const t=await e.json();this.textEmbedder.load(t)}else console.error("Failed to load vocabulary.json")}catch(e){console.error("Error loading vocabulary:",e)}await this.model.loadModel(e)}async predict(e,t=!0,s=[]){const a=[],n=[],o=[];let i=this.getInitialDeckStats();e.forEach((e=>{let t=null;if(e.includes(" - ")){const s=e.split(" - "),a=s[0].trim(),n=s.slice(1).join(" - ").trim(),o=this.getCardKey(a,n);this.cardMap.has(o)&&(t=this.cardMap.get(o))}if(null===t){const s=e.trim().toLowerCase();for(const[e,a]of this.cardMap.entries())if(e.toLowerCase().startsWith(s)){t=a;break}}if(null!==t){a.push(t);const e=this.indexMap.get(t);this.updateDeckStats(i,e);const s=a.filter((e=>e===t)).length-1,r=this.extractCardFeatures(e,i,s),l=this.textEmbedder.cardToTextIndices(e);n.push(r),o.push(l)}}));const r=new Map,l=new Set;a.forEach((e=>{r.set(e,(r.get(e)||0)+1);const t=this.indexMap.get(e);t&&t.ink&&l.add(t.ink)}));const d=await this.model.predict(a,n,o),h=this.boostSingletons(d,a,2.5),c=this.getAdaptiveTemperature(a.length),m=this.sampleTopP(h,c,.9),u=Array.from(h).map(((e,t)=>({index:t,prob:e}))).sort(((e,t)=>t.prob-e.prob)),p=[m,...u.map((e=>e.index)).filter((e=>e!==m))];for(const e of p){const a=this.indexMap.get(e);if(a&&!(t&&"legal"!==a.legality||(r.get(e)||0)>=(a.maxAmount||4))){if(s.length>0&&!(a.inks||(a.ink?[a.ink]:[])).every((e=>s.includes(e))))continue;if(!(l.size>=2)||l.has(a.ink))return a}}return null}getAdaptiveTemperature(e){return e<=10?2:e<=40?1:.8}boostSingletons(e,t,s=2){const a=Float32Array.from(e),n=new Map;for(const e of t)n.set(e,(n.get(e)||0)+1);for(const[e,t]of n)1===t&&e<a.length&&(a[e]*=s);let o=0;for(let e=0;e<a.length;e++)o+=a[e];if(o>0)for(let e=0;e<a.length;e++)a[e]/=o;return a}sampleTopP(e,t=1,s=.9){const a=Array.from(e).map(((e,s)=>({prob:Math.pow(Math.max(e,1e-10),1/t),index:s}))),n=a.reduce(((e,t)=>e+t.prob),0);a.forEach((e=>e.prob/=n)),a.sort(((e,t)=>t.prob-e.prob));let o=0;const i=[];for(const e of a)if(o+=e.prob,i.push(e),o>=s)break;0===i.length&&i.push(a[0]);const r=i.reduce(((e,t)=>e+t.prob),0),l=Math.random()*r;let d=0;for(const e of i)if(d+=e.prob,l<=d)return e.index;return i[i.length-1].index}getInitialDeckStats(){return{totalCards:0,inkableCount:0,costCounts:[0,0,0,0,0,0,0,0,0,0],inkableCostCounts:[0,0,0,0,0,0,0,0,0,0],typeCounts:{character:0,action:0,item:0,location:0},inkCounts:{Amber:0,Amethyst:0,Emerald:0,Ruby:0,Sapphire:0,Steel:0}}}updateDeckStats(e,t){e.totalCards++,t.inkwell&&e.inkableCount++;let s=Math.max(0,Math.min(t.cost-1,9));if(0===t.cost&&(s=0),e.costCounts[s]++,t.inkwell&&e.inkableCostCounts[s]++,t.ink&&(e.inkCounts[t.ink]||(e.inkCounts[t.ink]=0),e.inkCounts[t.ink]++),t.type){const s=t.type.toLowerCase();void 0!==e.typeCounts[s]&&e.typeCounts[s]++}}extractCardFeatures(e,t,s=0){const a=[];a.push(Math.min(e.cost,10)/10),a.push(e.inkwell?1:0),a.push(Math.min(e.lore||0,5)/5),a.push(Math.min(e.strength||0,10)/10),a.push(Math.min(e.willpower||0,10)/10),["Amber","Amethyst","Emerald","Ruby","Sapphire","Steel"].forEach((t=>{a.push(e.ink===t?1:0)}));const n=e.types&&e.types.length>0?e.types[0]:"";["Character","Action","Item","Location"].forEach((e=>{a.push(n===e?1:0)})),["Bodyguard","Reckless","Rush","Ward","Evasive","Resist","Challenger","Singer","Shift","Boost"].forEach((t=>{const s=`has${t}`;if(void 0!==e[s])a.push(e[s]?1:0);else{const s=e.keywords&&e.keywords.some((e=>e.includes(t)));a.push(s?1:0)}})),a.push(Math.min(e.resistAmount||0,10)/10),a.push(Math.min(e.challengerAmount||0,10)/10),a.push(Math.min(e.boostAmount||0,10)/10),a.push(Math.min(e.moveCost||0,10)/10),["Hero","Villain","Dreamborn","Storyborn","Floodborn"].forEach((t=>{a.push(e.classifications&&e.classifications.includes(t)?1:0)})),a.push(Math.min(s,4)/4);const o=Math.max(1,t.totalCards);return a.push(t.inkableCount/o),t.costCounts.forEach((e=>{a.push(e/o)})),Object.values(t.typeCounts).forEach((e=>{a.push(e/o)})),["Amber","Amethyst","Emerald","Ruby","Sapphire","Steel"].forEach((e=>{a.push((t.inkCounts[e]||0)/o)})),t.inkableCostCounts.forEach((e=>{a.push(e/o)})),a}getCardByName(e){let t=null;if(e.includes(" - ")){const s=e.split(" - "),a=s[0].trim(),n=s.slice(1).join(" - ").trim(),o=this.getCardKey(a,n);this.cardMap.has(o)&&(t=this.cardMap.get(o))}if(null===t){const s=e.trim().toLowerCase();for(const[e,a]of this.cardMap.entries())if(e.toLowerCase().startsWith(s)){t=a;break}}return null!==t?this.indexMap.get(t):null}async loadValidationModel(e){try{await this.validationModel.loadModel(e),this.validationModelLoaded=!0,console.log("Validation model loaded successfully")}catch(e){console.error("Failed to load validation model:",e),this.validationModelLoaded=!1}}computeCardEmbedding(e){const t=new Array(32).fill(0),s=[e.name||"",e.keywords?e.keywords.join(" "):"",e.classifications?e.classifications.join(" "):"",e.types?e.types.join(" "):"",e.ink||"",e.text||""].join(" ").toLowerCase();for(let e=0;e<s.length;e++)t[s.charCodeAt(e)%32]+=1;const a=Math.sqrt(t.reduce(((e,t)=>e+t*t),0));if(a>0)for(let e=0;e<32;e++)t[e]/=a;return t}extractDeckFeatures(e){const t=[],s=[];e.forEach((e=>{const t=this.getCardKey(e.name,e.version);this.cardMap.has(t)&&s.push(this.cardMap.get(t))}));const a=[0,0,0,0,0],n=new Map;for(const e of s)n.set(e,(n.get(e)||0)+1);const o=n.size;t.push(o/20);for(const e of n.values())1===e?a[0]++:2===e?a[1]++:3===e?a[2]++:4===e?a[3]++:a[4]++;const i=[...n.keys()].length;a.forEach(((e,s)=>t.push(e/Math.max(1,i))));const r=Array(10).fill(0);let l=0,d=s.length;const h={character:0,action:0,item:0,location:0},c={Amber:0,Amethyst:0,Emerald:0,Ruby:0,Sapphire:0,Steel:0},m={Ward:0,Evasive:0,Bodyguard:0,Resist:0,Singer:0,Shift:0,Reckless:0,Challenger:0,Rush:0},u=new Map;for(const e of s){const t=this.indexMap.get(e);if(t){if(r[Math.min(t.cost-1,9)]++,t.inkwell&&l++,t.types&&t.types.length>0){const e=t.types[0].toLowerCase();void 0!==h[e]&&h[e]++}t.ink&&void 0!==c[t.ink]&&c[t.ink]++;for(const e of Object.keys(m))(t[`has${e}`]||t.keywords&&t.keywords.some((t=>t.includes(e))))&&m[e]++;if(t.classifications)for(const e of t.classifications)u.set(e,(u.get(e)||0)+1)}}r.forEach((e=>t.push(e/d))),Object.values(h).forEach((e=>t.push(e/d))),Object.values(c).forEach((e=>t.push(e/d))),t.push(l/d),Object.values(m).forEach((e=>t.push(e/d))),t.push(u.size/10);const p=u.size>0?Array.from(u.values()).reduce(((e,t)=>e+t),0)/u.size/d:0;t.push(p);const k=[];for(const e of s){const t=this.indexMap.get(e);t&&k.push(this.computeCardEmbedding(t))}if(0===k.length){const e=new Array(96).fill(0);return t.push(...e),t}const y=32,g=new Array(y).fill(0),f=new Array(y).fill(-1/0);for(const e of k)for(let t=0;t<y;t++)g[t]+=e[t],f[t]=Math.max(f[t],e[t]);for(let e=0;e<y;e++)g[e]/=k.length;const x=new Array(y).fill(0);for(const e of k)for(let t=0;t<y;t++){const s=e[t]-g[t];x[t]+=s*s}for(let e=0;e<y;e++)x[e]/=k.length;return t.push(...g),t.push(...f),t.push(...x),t}async validateDeck(e){if(!this.validationModelLoaded)return console.warn("Validation model not loaded"),null;if(!e||e.length<60)return{score:0,grade:"D",message:"Deck must have 60 cards",breakdown:[]};const t=this.extractDeckFeatures(e),s=new Set(e.map((e=>this.getCardKey(e.name,e.version))));console.log("Validation features:",{featureCount:t.length,uniqueCardCount:s.size,singletonRatio:t[0],twoOfRatio:t[1],threeOfRatio:t[2],fourOfRatio:t[3],moreThanFourRatio:t[4],manaCurvePeak:Math.max(...t.slice(5,15)),characterRatio:t[15],inkableRatio:t[25],synergyScore:t[36],allFeatures:t});const a=await this.validationModel.evaluateWithBreakdown(t);return console.log("Validation result:",a),a}}var d=s(238),h=s(795),c=s(814),m=s(479),u=s(844);document.addEventListener("DOMContentLoaded",(async()=>{const e=new l,t=document.getElementById("generate-deck-btn"),s=document.getElementById("test-deck-btn"),a=document.getElementById("clear-deck-btn"),n=document.querySelector('[data-role="chart"]'),o=document.getElementById("legal-only"),i=new d.A(n);let r,p,k,y,g=[],f=[];y=new u.A;const x=document.querySelector('[data-role="deck"]');p=new c.A(x,{onRemove:e=>{const t=g.findIndex((t=>t.id===e));-1!==t&&(g.splice(t,1),v(),r.refresh())},onAdd:()=>r.show(),onCardClick:e=>y.show(e.image,e.name),isEditable:!0,showAddPlaceholder:!0}),k=new m.A(document.querySelector('[data-role="ink-selector"]'),{onChange:e=>{f=e;const t=g.filter((e=>f.includes(e.ink)||T(e,f)));t.length!==g.length&&(g=t,v()),r&&r.refresh()}}),v();try{console.log("Loading AI model..."),await e.loadModel("training_data/deck-generator-model/model.json"),console.log("Model loaded successfully!"),r=new h.A(e.cards,document.querySelector("[data-role=card-select]"),(e=>function(e){if(g.length>=60)return void alert("Deck is full (60 cards).");g.filter((t=>t.title===e.title)).length>=e.maxAmount?alert(`Cannot add more than ${e.maxAmount} copies of this card.`):(g.push(e),v(),r.refresh())}(e)),{filter:e=>!(f.length>0&&!f.includes(e.ink)&&!T(e,f))&&g.filter((t=>t.title===e.title)).length<e.maxAmount,renderButtonText:e=>{const t=g.filter((t=>t.title===e.title)).length;return t>=e.maxAmount?`Max Reached <small>(${t}/${e.maxAmount})</small>`:`Add Card (${t}/${e.maxAmount})`}}),t.disabled=!1;try{console.log("Loading validation model..."),await e.loadValidationModel("training_data/deck-validator-model/model.json"),console.log("Validation model loaded!")}catch(e){console.warn("Validation model not available:",e)}}catch(e){console.error("Failed to load model:",e),alert("Failed to load AI model. Please refresh the page.")}function T(e,t){return!(2!==t.length||!e.inks)&&t.includes(e.inks[0])&&t.includes(e.inks[1])}function v(){p.render(g,f),s.classList.remove("hidden"),g.length<60&&s.classList.add("hidden"),g.length>0?i.renderChart(g):i.renderChart([]),async function(){console.log("updateValidationScore called, deck length:",g.length);const t=document.querySelector('[data-role="validation-score"]');if(t)if(g.length<60)t.innerHTML=`\n                <div class="validation-card">\n                    <div class="validation-header">\n                        <h3>Deck Realism</h3>\n                        <span class="validation-grade grade-empty">-</span>\n                    </div>\n                    <div class="validation-message">Add ${60-g.length} more cards</div>\n                </div>\n            `;else try{console.log("Calling manager.validateDeck...");const s=await e.validateDeck(g);if(console.log("Validation result received:",s),!s)return void(t.innerHTML="");const a=Math.round(100*s.score),n="A"===s.grade?"grade-a":"B"===s.grade?"grade-b":"C"===s.grade?"grade-c":"grade-d";let o="";s.breakdown&&s.breakdown.length>0&&(o='<div class="validation-breakdown">',o+="<h4>Issues Detected:</h4>",o+="<ul>",s.breakdown.forEach((e=>{const t="high"===e.severity?"severity-high":"severity-medium";o+=`<li class="${t}"><strong>${e.issue}:</strong> ${e.message}</li>`})),o+="</ul></div>"),t.innerHTML=`\n                <div class="validation-card">\n                    <div class="validation-header">\n                        <h3>Deck Realism</h3>\n                        <span class="validation-grade ${n}">${s.grade}</span>\n                    </div>\n                    <div class="validation-score">${a}%</div>\n                    <div class="validation-message">${s.message}</div>\n                    ${o}\n                </div>\n            `}catch(e){console.error("Error in updateValidationScore:",e),t.innerHTML=`\n                <div class="validation-card">\n                    <div class="validation-message" style="color: #ef4444;">\n                        Error loading validation: ${e.message}\n                    </div>\n                </div>\n            `}else console.warn("Validation container not found")}()}t.addEventListener("click",(async()=>{t.disabled=!0;const s=o.checked;for(;g.length<60;){const t=g.map((e=>e.version?`${e.name} - ${e.version}`:e.name)),a=await e.predict(t,s,f);if(!a||"string"==typeof a){console.warn("No valid prediction:",a);break}g.push(a),v(),await new Promise((e=>setTimeout(e,10)))}t.disabled=!1})),a.addEventListener("click",(()=>{g=[],v(),s.classList.add("hidden")})),s.addEventListener("click",(()=>{window.open(function(){const e=Math.random().toString(36).substring(7);let t=`AI Generated Deck: ${f[0]} - ${f[1]} - ${e}`;t=encodeURIComponent(t);let s="";const a=[...new Set(g.map((e=>e.title)))];for(const e of a){const t=g.filter((t=>t.title===e)).length;s+=`${e}$${t}|`}return`https://inktable.net/lor/import?svc=dreamborn&name=${t}&id=${btoa(s)}`}(),"_blank")}))}))},817:()=>{},590:()=>{},530:()=>{},108:()=>{},551:()=>{},234:()=>{}},e=>{e.O(0,[839,122,452],(()=>e(e.s=580))),e.O()}]);