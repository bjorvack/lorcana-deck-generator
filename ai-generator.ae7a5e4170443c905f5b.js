(self.webpackChunklorcana_deck_generator=self.webpackChunklorcana_deck_generator||[]).push([[745],{495:(e,t,s)=>{"use strict";var n=s(947),a=s(122);class i{constructor(){this.model=null,this.vocabSize=0,this.featureDim=0,this.maxLen=60,this.embeddingDim=32,this.lstmUnits=64,this.textVocabSize=0,this.maxTextTokens=0,this.textEmbeddingDim=16}async initialize(e,t,s,n,i,o,r,h,l){this.vocabSize=e+1,this.featureDim=t,this.textVocabSize=s,this.maxNameTokens=n,this.maxKeywordsTokens=i,this.maxInkTokens=o,this.maxClassTokens=r,this.maxTypeTokens=h,this.maxBodyTokens=l;const d=a.hFB({shape:[this.maxLen,this.featureDim],dtype:"float32",name:"input_features"}),m=a.hFB({shape:[this.maxLen,this.maxNameTokens],dtype:"int32",name:"input_name_tokens"}),c=a.hFB({shape:[this.maxLen,this.maxKeywordsTokens],dtype:"int32",name:"input_keywords_tokens"}),p=a.hFB({shape:[this.maxLen,this.maxInkTokens],dtype:"int32",name:"input_ink_tokens"}),u=a.hFB({shape:[this.maxLen,this.maxClassTokens],dtype:"int32",name:"input_class_tokens"}),k=a.hFB({shape:[this.maxLen,this.maxTypeTokens],dtype:"int32",name:"input_type_tokens"}),x=a.hFB({shape:[this.maxLen,this.maxBodyTokens],dtype:"int32",name:"input_body_tokens"}),y=a.ZFI.embedding({inputDim:this.textVocabSize,outputDim:this.textEmbeddingDim,name:"shared_text_embedding"}),T=(e,t,s,n)=>{const i=y.apply(e),o=a.ZFI.reshape({targetShape:[this.maxLen,t*this.textEmbeddingDim],name:`${s}_flatten`}).apply(i);return a.ZFI.dense({units:n,activation:"relu",name:`${s}_projection`}).apply(o)},f=T(m,this.maxNameTokens,"name",8),g=T(c,this.maxKeywordsTokens,"keywords",12),C=T(p,this.maxInkTokens,"ink",4),b=T(u,this.maxClassTokens,"class",8),w=T(k,this.maxTypeTokens,"type",4),A=T(x,this.maxBodyTokens,"body",24),I=a.ZFI.concatenate({name:"concat_all_features"}).apply([d,f,g,C,b,w,A]),M=a.ZFI.lstm({units:this.lstmUnits,returnSequences:!1,name:"lstm"}).apply(I),E=a.ZFI.dense({units:this.vocabSize,activation:"softmax",name:"output"}).apply(M);this.model=a.geq({inputs:[d,m,c,p,u,k,x],outputs:E,name:"deck_predictor"}),this.model.compile({optimizer:a.BaG.adam(.001),loss:"sparseCategoricalCrossentropy",metrics:["accuracy"]}),this.model.summary()}async train(e,t,s,n,a){console.warn("Training in frontend is not fully implemented/optimized.")}prepareData(e,t){return{}}async predict(e,t,s){if(!this.model)return null;const n=Math.max(0,this.maxLen-e.length),i=[];for(let e=0;e<this.maxLen;e++)i.push(Array(this.featureDim).fill(0));for(let e=0;e<Math.min(t.length,this.maxLen);e++)i[n+e]=t[e];!this.maxNameTokens&&this.model.inputs.length>1&&(this.maxNameTokens=this.model.inputs[1].shape[2],this.maxKeywordsTokens=this.model.inputs[2].shape[2],this.maxInkTokens=this.model.inputs[3].shape[2],this.maxClassTokens=this.model.inputs[4].shape[2],this.maxTypeTokens=this.model.inputs[5].shape[2],this.maxBodyTokens=this.model.inputs[6].shape[2]);const o=[],r=[],h=[],l=[],d=[],m=[];for(let e=0;e<this.maxLen;e++)o.push(Array(this.maxNameTokens).fill(0)),r.push(Array(this.maxKeywordsTokens).fill(0)),h.push(Array(this.maxInkTokens).fill(0)),l.push(Array(this.maxClassTokens).fill(0)),d.push(Array(this.maxTypeTokens).fill(0)),m.push(Array(this.maxBodyTokens).fill(0));if(s)for(let e=0;e<Math.min(s.length,this.maxLen);e++){const t=s[e],a=(e,t)=>{const s=e.slice(0,t);return s.concat(Array(t-s.length).fill(0))};o[n+e]=a(t.name,this.maxNameTokens),r[n+e]=a(t.keywords,this.maxKeywordsTokens),h[n+e]=a(t.ink,this.maxInkTokens),l[n+e]=a(t.classifications,this.maxClassTokens),d[n+e]=a(t.types,this.maxTypeTokens),m[n+e]=a(t.text,this.maxBodyTokens)}const c=a.$_$([i],[1,this.maxLen,this.featureDim]),p=a.$_$([o],[1,this.maxLen,this.maxNameTokens]),u=a.$_$([r],[1,this.maxLen,this.maxKeywordsTokens]),k=a.$_$([h],[1,this.maxLen,this.maxInkTokens]),x=a.$_$([l],[1,this.maxLen,this.maxClassTokens]),y=a.$_$([d],[1,this.maxLen,this.maxTypeTokens]),T=a.$_$([m],[1,this.maxLen,this.maxBodyTokens]),f=this.model.predict([c,p,u,k,x,y,T]),g=await f.data();return c.dispose(),p.dispose(),u.dispose(),k.dispose(),x.dispose(),y.dispose(),T.dispose(),f.dispose(),g}async saveModel(e){this.model&&(e.startsWith("file://")||(e=`file://${e}`),await this.model.save(e))}async loadModel(e){this.model=await a.O0W(e),this.model.compile({optimizer:"adam",loss:"sparseCategoricalCrossentropy",metrics:["accuracy"]}),this.model.inputs&&this.model.inputs.length>0&&(this.featureDim=this.model.inputs[0].shape[2]),this.model.inputs&&this.model.inputs.length>1&&(this.maxNameTokens=this.model.inputs[1].shape[2]),this.model.inputs&&this.model.inputs.length>2&&(this.maxKeywordsTokens=this.model.inputs[2].shape[2]),this.model.inputs&&this.model.inputs.length>3&&(this.maxInkTokens=this.model.inputs[3].shape[2]),this.model.inputs&&this.model.inputs.length>4&&(this.maxClassTokens=this.model.inputs[4].shape[2]),this.model.inputs&&this.model.inputs.length>5&&(this.maxTypeTokens=this.model.inputs[5].shape[2]),this.model.inputs&&this.model.inputs.length>6&&(this.maxBodyTokens=this.model.inputs[6].shape[2]),this.model.summary()}}class o{constructor(){this.tokenToIndex={"<PAD>":0,"<UNK>":1},this.indexToToken={0:"<PAD>",1:"<UNK>"},this.vocabularySize=2,this.maxNameTokens=5,this.maxKeywordsTokens=10,this.maxInkTokens=2,this.maxClassTokens=5,this.maxTypeTokens=3,this.maxBodyTokens=30,this.allCardNames=[]}load(e){this.tokenToIndex=e.tokenToIndex,this.indexToToken=e.indexToToken,this.vocabularySize=e.vocabularySize,this.maxNameTokens=e.maxNameTokens||5,this.maxKeywordsTokens=e.maxKeywordsTokens||10,this.maxInkTokens=e.maxInkTokens||2,this.maxClassTokens=e.maxClassTokens||5,this.maxTypeTokens=e.maxTypeTokens||3,this.maxBodyTokens=e.maxBodyTokens||30,this.allCardNames=e.allCardNames||[],console.log(`Vocabulary loaded (${this.vocabularySize} tokens)`)}cleanText(e){if(!e)return"";let t=e.toLowerCase();return t=t.replace(/\{e\}/g," exert "),t=t.replace(/[^a-z0-9\s+\{\}]/g,""),t.trim()}extractTextTokens(e,t){const s=[];let n=this.cleanText(e);t.forEach((e=>{n.includes(e)&&(s.push(e),n=n.replace(new RegExp(e,"g")," "))}));const a=n.split(/\s+/).map((e=>e.trim())).filter((e=>e.length>2||"+"===e||"{"===e||"}"===e));return s.push(...a),s}cardToTextIndices(e){const t=[],s=this.cleanText(e.name);s&&(void 0!==this.tokenToIndex[s]?t.push(this.tokenToIndex[s]):t.push(this.tokenToIndex["<UNK>"]));const n=[];e.keywords&&Array.isArray(e.keywords)&&e.keywords.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];n.push(s)}));const a=[];if(e.ink){const t=this.cleanText(e.ink),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];a.push(s)}const i=[];e.classifications&&Array.isArray(e.classifications)&&e.classifications.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];i.push(s)}));const o=[];e.types&&Array.isArray(e.types)?e.types.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];o.push(s)})):e.type&&Array.isArray(e.type)&&e.type.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];o.push(s)}));const r=[];let h=e.sanitizedText;return!h&&e.text&&(h=e.text.toLowerCase().replace(/\([^)]+\)/g,"").replace(/\(|\)/g,"").trim()),h&&this.extractTextTokens(h,this.allCardNames).forEach((e=>{const t=this.tokenToIndex[e]||this.tokenToIndex["<UNK>"];r.push(t)})),{name:this.padOrTruncate(t,this.maxNameTokens),keywords:this.padOrTruncate(n,this.maxKeywordsTokens),ink:this.padOrTruncate(a,this.maxInkTokens),classifications:this.padOrTruncate(i,this.maxClassTokens),types:this.padOrTruncate(o,this.maxTypeTokens),text:this.padOrTruncate(r,this.maxBodyTokens)}}padOrTruncate(e,t){if(e.length>=t)return e.slice(0,t);const s=[...e];for(;s.length<t;)s.push(0);return s}}class r{constructor(){this.cardApi=new n.A,this.model=new i,this.textEmbedder=new o,this.cards=[],this.cardMap=new Map,this.indexMap=new Map}getCardKey(e,t){return t?`${e} - ${t}`:e}async loadCards(){return 0===this.cards.length&&(this.cards=await this.cardApi.getCards(),this.cards.forEach((e=>{const t=this.getCardKey(e.name,e.version);if(!this.cardMap.has(t)){const s=this.cardMap.size;this.cardMap.set(t,s),this.indexMap.set(s,e)}}))),this.cards}async loadModel(e){await this.loadCards();try{const e=await fetch("training_data/vocabulary.json");if(e.ok){const t=await e.json();this.textEmbedder.load(t)}else console.error("Failed to load vocabulary.json")}catch(e){console.error("Error loading vocabulary:",e)}await this.model.loadModel(e)}async predict(e,t=!0,s=[]){const n=[],a=[],i=[];let o=this.getInitialDeckStats();e.forEach((e=>{let t=null;if(e.includes(" - ")){const s=e.split(" - "),n=s[0].trim(),a=s.slice(1).join(" - ").trim(),i=this.getCardKey(n,a);this.cardMap.has(i)&&(t=this.cardMap.get(i))}if(null===t){const s=e.trim().toLowerCase();for(const[e,n]of this.cardMap.entries())if(e.toLowerCase().startsWith(s)){t=n;break}}if(null!==t){n.push(t);const e=this.indexMap.get(t);this.updateDeckStats(o,e);const s=n.filter((e=>e===t)).length-1,r=this.extractCardFeatures(e,o,s),h=this.textEmbedder.cardToTextIndices(e);a.push(r),i.push(h)}}));const r=new Map,h=new Set;n.forEach((e=>{r.set(e,(r.get(e)||0)+1);const t=this.indexMap.get(e);t&&t.ink&&h.add(t.ink)}));const l=await this.model.predict(n,a,i),d=this.boostSingletons(l,n,2.5),m=this.getAdaptiveTemperature(n.length),c=this.sampleTopP(d,m,.9),p=Array.from(d).map(((e,t)=>({index:t,prob:e}))).sort(((e,t)=>t.prob-e.prob)),u=[c,...p.map((e=>e.index)).filter((e=>e!==c))];for(const e of u){const n=this.indexMap.get(e);if(n&&!(t&&"legal"!==n.legality||(r.get(e)||0)>=(n.maxAmount||4))){if(s.length>0&&!(n.inks||(n.ink?[n.ink]:[])).every((e=>s.includes(e))))continue;if(!(h.size>=2)||h.has(n.ink))return n}}return null}getAdaptiveTemperature(e){return e<=10?2:e<=40?1:.8}boostSingletons(e,t,s=2){const n=Float32Array.from(e),a=new Map;for(const e of t)a.set(e,(a.get(e)||0)+1);for(const[e,t]of a)1===t&&e<n.length&&(n[e]*=s);let i=0;for(let e=0;e<n.length;e++)i+=n[e];if(i>0)for(let e=0;e<n.length;e++)n[e]/=i;return n}sampleTopP(e,t=1,s=.9){const n=Array.from(e).map(((e,s)=>({prob:Math.pow(Math.max(e,1e-10),1/t),index:s}))),a=n.reduce(((e,t)=>e+t.prob),0);n.forEach((e=>e.prob/=a)),n.sort(((e,t)=>t.prob-e.prob));let i=0;const o=[];for(const e of n)if(i+=e.prob,o.push(e),i>=s)break;0===o.length&&o.push(n[0]);const r=o.reduce(((e,t)=>e+t.prob),0),h=Math.random()*r;let l=0;for(const e of o)if(l+=e.prob,h<=l)return e.index;return o[o.length-1].index}getInitialDeckStats(){return{totalCards:0,inkableCount:0,costCounts:[0,0,0,0,0,0,0,0,0,0],inkableCostCounts:[0,0,0,0,0,0,0,0,0,0],typeCounts:{character:0,action:0,item:0,location:0},inkCounts:{Amber:0,Amethyst:0,Emerald:0,Ruby:0,Sapphire:0,Steel:0}}}updateDeckStats(e,t){e.totalCards++,t.inkwell&&e.inkableCount++;let s=Math.max(0,Math.min(t.cost-1,9));if(0===t.cost&&(s=0),e.costCounts[s]++,t.inkwell&&e.inkableCostCounts[s]++,t.ink&&(e.inkCounts[t.ink]||(e.inkCounts[t.ink]=0),e.inkCounts[t.ink]++),t.type){const s=t.type.toLowerCase();void 0!==e.typeCounts[s]&&e.typeCounts[s]++}}extractCardFeatures(e,t,s=0){const n=[];n.push(Math.min(e.cost,10)/10),n.push(e.inkwell?1:0),n.push(Math.min(e.lore||0,5)/5),n.push(Math.min(e.strength||0,10)/10),n.push(Math.min(e.willpower||0,10)/10),["Amber","Amethyst","Emerald","Ruby","Sapphire","Steel"].forEach((t=>{n.push(e.ink===t?1:0)}));const a=e.types&&e.types.length>0?e.types[0]:"";["Character","Action","Item","Location"].forEach((e=>{n.push(a===e?1:0)})),["Bodyguard","Reckless","Rush","Ward","Evasive","Resist","Challenger","Singer","Shift","Boost"].forEach((t=>{const s=`has${t}`;if(void 0!==e[s])n.push(e[s]?1:0);else{const s=e.keywords&&e.keywords.some((e=>e.includes(t)));n.push(s?1:0)}})),n.push(Math.min(e.resistAmount||0,10)/10),n.push(Math.min(e.challengerAmount||0,10)/10),n.push(Math.min(e.boostAmount||0,10)/10),n.push(Math.min(e.moveCost||0,10)/10),["Hero","Villain","Dreamborn","Storyborn","Floodborn"].forEach((t=>{n.push(e.classifications&&e.classifications.includes(t)?1:0)})),n.push(Math.min(s,4)/4);const i=Math.max(1,t.totalCards);return n.push(t.inkableCount/i),t.costCounts.forEach((e=>{n.push(e/i)})),Object.values(t.typeCounts).forEach((e=>{n.push(e/i)})),["Amber","Amethyst","Emerald","Ruby","Sapphire","Steel"].forEach((e=>{n.push((t.inkCounts[e]||0)/i)})),t.inkableCostCounts.forEach((e=>{n.push(e/i)})),n}getCardByName(e){let t=null;if(e.includes(" - ")){const s=e.split(" - "),n=s[0].trim(),a=s.slice(1).join(" - ").trim(),i=this.getCardKey(n,a);this.cardMap.has(i)&&(t=this.cardMap.get(i))}if(null===t){const s=e.trim().toLowerCase();for(const[e,n]of this.cardMap.entries())if(e.toLowerCase().startsWith(s)){t=n;break}}return null!==t?this.indexMap.get(t):null}}var h=s(238),l=s(795),d=s(814),m=s(479),c=s(844);document.addEventListener("DOMContentLoaded",(async()=>{const e=new r,t=document.getElementById("generate-deck-btn"),s=document.getElementById("test-deck-btn"),n=document.getElementById("clear-deck-btn"),a=document.querySelector('[data-role="chart"]'),i=document.getElementById("legal-only"),o=new h.A(a);let p,u,k,x,y=[],T=[];x=new c.A;const f=document.querySelector('[data-role="deck"]');u=new d.A(f,{onRemove:e=>{const t=y.findIndex((t=>t.id===e));-1!==t&&(y.splice(t,1),C(),p.refresh())},onAdd:()=>p.show(),onCardClick:e=>x.show(e.image,e.name),isEditable:!0,showAddPlaceholder:!0}),k=new m.A(document.querySelector('[data-role="ink-selector"]'),{onChange:e=>{T=e;const t=y.filter((e=>T.includes(e.ink)||g(e,T)));t.length!==y.length&&(y=t,C()),p&&p.refresh()}}),C();try{console.log("Loading AI model..."),await e.loadModel("training_data/deck-generator-model/model.json"),console.log("Model loaded successfully!"),p=new l.A(e.cards,document.querySelector("[data-role=card-select]"),(e=>function(e){if(y.length>=60)return void alert("Deck is full (60 cards).");y.filter((t=>t.title===e.title)).length>=e.maxAmount?alert(`Cannot add more than ${e.maxAmount} copies of this card.`):(y.push(e),C(),p.refresh())}(e)),{filter:e=>!(T.length>0&&!T.includes(e.ink)&&!g(e,T))&&y.filter((t=>t.title===e.title)).length<e.maxAmount,renderButtonText:e=>{const t=y.filter((t=>t.title===e.title)).length;return t>=e.maxAmount?`Max Reached <small>(${t}/${e.maxAmount})</small>`:`Add Card (${t}/${e.maxAmount})`}}),t.disabled=!1}catch(e){console.error("Failed to load model:",e),alert("Failed to load AI model. Please refresh the page.")}function g(e,t){return!(2!==t.length||!e.inks)&&t.includes(e.inks[0])&&t.includes(e.inks[1])}function C(){u.render(y,T),s.classList.remove("hidden"),y.length<60&&s.classList.add("hidden"),y.length>0?o.renderChart(y):o.renderChart([])}t.addEventListener("click",(async()=>{t.disabled=!0;const s=i.checked;for(;y.length<60;){const t=y.map((e=>e.version?`${e.name} - ${e.version}`:e.name)),n=await e.predict(t,s,T);if(!n||"string"==typeof n){console.warn("No valid prediction:",n);break}y.push(n),C(),await new Promise((e=>setTimeout(e,10)))}t.disabled=!1})),n.addEventListener("click",(()=>{y=[],C(),s.classList.add("hidden")})),s.addEventListener("click",(()=>{window.open(function(){const e=Math.random().toString(36).substring(7);let t=`AI Generated Deck: ${T[0]} - ${T[1]} - ${e}`;t=encodeURIComponent(t);let s="";const n=[...new Set(y.map((e=>e.title)))];for(const e of n){const t=y.filter((t=>t.title===e)).length;s+=`${e}$${t}|`}return`https://inktable.net/lor/import?svc=dreamborn&name=${t}&id=${btoa(s)}`}(),"_blank")}))}))},817:()=>{},590:()=>{},530:()=>{},108:()=>{},551:()=>{},234:()=>{}},e=>{e.O(0,[839,122,452],(()=>e(e.s=495))),e.O()}]);