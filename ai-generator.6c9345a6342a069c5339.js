(self.webpackChunklorcana_deck_generator=self.webpackChunklorcana_deck_generator||[]).push([[745],{580:(e,t,s)=>{"use strict";var a=s(947),n=s(122);class i{constructor(){this.model=null,this.vocabSize=0,this.featureDim=0,this.maxLen=60,this.embeddingDim=32,this.lstmUnits=64,this.textVocabSize=0,this.maxTextTokens=0,this.textEmbeddingDim=16}async initialize(e,t,s,a,i,o,r,l,h){this.vocabSize=e+1,this.featureDim=t,this.textVocabSize=s,this.maxNameTokens=a,this.maxKeywordsTokens=i,this.maxInkTokens=o,this.maxClassTokens=r,this.maxTypeTokens=l,this.maxBodyTokens=h;const d=n.hFB({shape:[this.maxLen,this.featureDim],dtype:"float32",name:"input_features"}),c=n.hFB({shape:[this.maxLen,this.maxNameTokens],dtype:"int32",name:"input_name_tokens"}),m=n.hFB({shape:[this.maxLen,this.maxKeywordsTokens],dtype:"int32",name:"input_keywords_tokens"}),u=n.hFB({shape:[this.maxLen,this.maxInkTokens],dtype:"int32",name:"input_ink_tokens"}),p=n.hFB({shape:[this.maxLen,this.maxClassTokens],dtype:"int32",name:"input_class_tokens"}),k=n.hFB({shape:[this.maxLen,this.maxTypeTokens],dtype:"int32",name:"input_type_tokens"}),y=n.hFB({shape:[this.maxLen,this.maxBodyTokens],dtype:"int32",name:"input_body_tokens"}),x=n.ZFI.embedding({inputDim:this.textVocabSize,outputDim:this.textEmbeddingDim,name:"shared_text_embedding"}),g=(e,t,s,a)=>{const i=x.apply(e),o=n.ZFI.reshape({targetShape:[this.maxLen,t*this.textEmbeddingDim],name:`${s}_flatten`}).apply(i);return n.ZFI.dense({units:a,activation:"relu",name:`${s}_projection`}).apply(o)},f=g(c,this.maxNameTokens,"name",8),T=g(m,this.maxKeywordsTokens,"keywords",12),v=g(u,this.maxInkTokens,"ink",4),w=g(p,this.maxClassTokens,"class",8),b=g(k,this.maxTypeTokens,"type",4),C=g(y,this.maxBodyTokens,"body",24),M=n.ZFI.concatenate({name:"concat_all_features"}).apply([d,f,T,v,w,b,C]),A=n.ZFI.lstm({units:this.lstmUnits,returnSequences:!1,name:"lstm"}).apply(M),I=n.ZFI.dense({units:this.vocabSize,activation:"softmax",name:"output"}).apply(A);this.model=n.geq({inputs:[d,c,m,u,p,k,y],outputs:I,name:"deck_predictor"}),this.model.compile({optimizer:n.BaG.adam(.001),loss:"sparseCategoricalCrossentropy",metrics:["accuracy"]}),this.model.summary()}async train(e,t,s,a,n){console.warn("Training in frontend is not fully implemented/optimized.")}prepareData(e,t){return{}}async predict(e,t,s){if(!this.model)return null;const a=Math.max(0,this.maxLen-e.length),i=[];for(let e=0;e<this.maxLen;e++)i.push(Array(this.featureDim).fill(0));for(let e=0;e<Math.min(t.length,this.maxLen);e++)i[a+e]=t[e];!this.maxNameTokens&&this.model.inputs.length>1&&(this.maxNameTokens=this.model.inputs[1].shape[2],this.maxKeywordsTokens=this.model.inputs[2].shape[2],this.maxInkTokens=this.model.inputs[3].shape[2],this.maxClassTokens=this.model.inputs[4].shape[2],this.maxTypeTokens=this.model.inputs[5].shape[2],this.maxBodyTokens=this.model.inputs[6].shape[2]);const o=[],r=[],l=[],h=[],d=[],c=[];for(let e=0;e<this.maxLen;e++)o.push(Array(this.maxNameTokens).fill(0)),r.push(Array(this.maxKeywordsTokens).fill(0)),l.push(Array(this.maxInkTokens).fill(0)),h.push(Array(this.maxClassTokens).fill(0)),d.push(Array(this.maxTypeTokens).fill(0)),c.push(Array(this.maxBodyTokens).fill(0));if(s)for(let e=0;e<Math.min(s.length,this.maxLen);e++){const t=s[e],n=(e,t)=>{const s=e.slice(0,t);return s.concat(Array(t-s.length).fill(0))};o[a+e]=n(t.name,this.maxNameTokens),r[a+e]=n(t.keywords,this.maxKeywordsTokens),l[a+e]=n(t.ink,this.maxInkTokens),h[a+e]=n(t.classifications,this.maxClassTokens),d[a+e]=n(t.types,this.maxTypeTokens),c[a+e]=n(t.text,this.maxBodyTokens)}const m=n.$_$([i],[1,this.maxLen,this.featureDim]),u=n.$_$([o],[1,this.maxLen,this.maxNameTokens]),p=n.$_$([r],[1,this.maxLen,this.maxKeywordsTokens]),k=n.$_$([l],[1,this.maxLen,this.maxInkTokens]),y=n.$_$([h],[1,this.maxLen,this.maxClassTokens]),x=n.$_$([d],[1,this.maxLen,this.maxTypeTokens]),g=n.$_$([c],[1,this.maxLen,this.maxBodyTokens]),f=this.model.predict([m,u,p,k,y,x,g]),T=await f.data();return m.dispose(),u.dispose(),p.dispose(),k.dispose(),y.dispose(),x.dispose(),g.dispose(),f.dispose(),T}async saveModel(e){this.model&&(e.startsWith("file://")||(e=`file://${e}`),await this.model.save(e))}async loadModel(e){this.model=await n.O0W(e),this.model.compile({optimizer:"adam",loss:"sparseCategoricalCrossentropy",metrics:["accuracy"]}),this.model.inputs&&this.model.inputs.length>0&&(this.featureDim=this.model.inputs[0].shape[2]),this.model.inputs&&this.model.inputs.length>1&&(this.maxNameTokens=this.model.inputs[1].shape[2]),this.model.inputs&&this.model.inputs.length>2&&(this.maxKeywordsTokens=this.model.inputs[2].shape[2]),this.model.inputs&&this.model.inputs.length>3&&(this.maxInkTokens=this.model.inputs[3].shape[2]),this.model.inputs&&this.model.inputs.length>4&&(this.maxClassTokens=this.model.inputs[4].shape[2]),this.model.inputs&&this.model.inputs.length>5&&(this.maxTypeTokens=this.model.inputs[5].shape[2]),this.model.inputs&&this.model.inputs.length>6&&(this.maxBodyTokens=this.model.inputs[6].shape[2]),this.model.summary()}}class o{constructor(){this.tokenToIndex={"<PAD>":0,"<UNK>":1},this.indexToToken={0:"<PAD>",1:"<UNK>"},this.vocabularySize=2,this.maxNameTokens=5,this.maxKeywordsTokens=10,this.maxInkTokens=2,this.maxClassTokens=5,this.maxTypeTokens=3,this.maxBodyTokens=30,this.allCardNames=[]}load(e){this.tokenToIndex=e.tokenToIndex,this.indexToToken=e.indexToToken,this.vocabularySize=e.vocabularySize,this.maxNameTokens=e.maxNameTokens||5,this.maxKeywordsTokens=e.maxKeywordsTokens||10,this.maxInkTokens=e.maxInkTokens||2,this.maxClassTokens=e.maxClassTokens||5,this.maxTypeTokens=e.maxTypeTokens||3,this.maxBodyTokens=e.maxBodyTokens||30,this.allCardNames=e.allCardNames||[],console.log(`Vocabulary loaded (${this.vocabularySize} tokens)`)}cleanText(e){if(!e)return"";let t=e.toLowerCase();return t=t.replace(/\{e\}/g," exert "),t=t.replace(/[^a-z0-9\s+\{\}]/g,""),t.trim()}extractTextTokens(e,t){const s=[];let a=this.cleanText(e);t.forEach((e=>{a.includes(e)&&(s.push(e),a=a.replace(new RegExp(e,"g")," "))}));const n=a.split(/\s+/).map((e=>e.trim())).filter((e=>e.length>2||"+"===e||"{"===e||"}"===e));return s.push(...n),s}cardToTextIndices(e){const t=[],s=this.cleanText(e.name);s&&(void 0!==this.tokenToIndex[s]?t.push(this.tokenToIndex[s]):t.push(this.tokenToIndex["<UNK>"]));const a=[];e.keywords&&Array.isArray(e.keywords)&&e.keywords.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];a.push(s)}));const n=[];if(e.ink){const t=this.cleanText(e.ink),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];n.push(s)}const i=[];e.classifications&&Array.isArray(e.classifications)&&e.classifications.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];i.push(s)}));const o=[];e.types&&Array.isArray(e.types)?e.types.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];o.push(s)})):e.type&&Array.isArray(e.type)&&e.type.forEach((e=>{const t=this.cleanText(e),s=this.tokenToIndex[t]||this.tokenToIndex["<UNK>"];o.push(s)}));const r=[];let l=e.sanitizedText;return!l&&e.text&&(l=e.text.toLowerCase().replace(/\([^)]+\)/g,"").replace(/\(|\)/g,"").trim()),l&&this.extractTextTokens(l,this.allCardNames).forEach((e=>{const t=this.tokenToIndex[e]||this.tokenToIndex["<UNK>"];r.push(t)})),{name:this.padOrTruncate(t,this.maxNameTokens),keywords:this.padOrTruncate(a,this.maxKeywordsTokens),ink:this.padOrTruncate(n,this.maxInkTokens),classifications:this.padOrTruncate(i,this.maxClassTokens),types:this.padOrTruncate(o,this.maxTypeTokens),text:this.padOrTruncate(r,this.maxBodyTokens)}}padOrTruncate(e,t){if(e.length>=t)return e.slice(0,t);const s=[...e];for(;s.length<t;)s.push(0);return s}}class r{constructor(){this.model=null,this.featureDim=0,this.thresholds={excellent:.85,good:.7,fair:.5,poor:0}}async loadModel(e){this.model=await n.O0W(e),this.model.compile({optimizer:"adam",loss:"binaryCrossentropy",metrics:["accuracy"]}),this.model.inputs&&this.model.inputs.length>0&&(this.featureDim=this.model.inputs[0].shape[1]),console.log("Validation model loaded successfully")}async evaluate(e){if(!this.model)return null;const t=n.KtR([e]),s=this.model.predict(t),a=(await s.data())[0];return t.dispose(),s.dispose(),a}async evaluateWithBreakdown(e){const t=await this.evaluate(e),s=this.analyzeFeatures(e);return{score:t,grade:this.getGrade(t),message:this.getMessage(t),breakdown:s}}analyzeFeatures(e){const t=[],s=e[0];s>.3&&t.push({issue:"High singleton count",severity:"high",message:`${Math.round(100*s)}% of unique cards have only 1 copy`});const a=e.slice(5,15);this.calculateVariance(a)<.005&&t.push({issue:"Flat mana curve",severity:"medium",message:"Mana curve is too uniform (expected bell curve)"});const n=e[25];(n<.4||n>.8)&&t.push({issue:"Unusual inkable ratio",severity:"medium",message:`${Math.round(100*n)}% inkable cards (expected 50-70%)`});const i=e[15];return i<.3&&t.push({issue:"Low character count",severity:"high",message:`Only ${Math.round(100*i)}% characters`}),e[36]<.1&&t.push({issue:"Low synergy",severity:"medium",message:"Cards appear to lack thematic cohesion"}),t}calculateVariance(e){const t=e.reduce(((e,t)=>e+t),0)/e.length;return e.map((e=>Math.pow(e-t,2))).reduce(((e,t)=>e+t),0)/e.length}getGrade(e){return e>=this.thresholds.excellent?"A":e>=this.thresholds.good?"B":e>=this.thresholds.fair?"C":"D"}getMessage(e){return e>=this.thresholds.excellent?"This deck looks authentic!":e>=this.thresholds.good?"This deck looks realistic with minor issues":e>=this.thresholds.fair?"This deck has some unrealistic patterns":"This deck seems randomly generated"}}class l{constructor(){this.cardApi=new a.A,this.model=new i,this.textEmbedder=new o,this.validationModel=new r,this.validationModelLoaded=!1,this.cards=[],this.cardMap=new Map,this.indexMap=new Map}getCardKey(e,t){return t?`${e} - ${t}`:e}async loadCards(){return 0===this.cards.length&&(this.cards=await this.cardApi.getCards(),this.cards.forEach((e=>{const t=this.getCardKey(e.name,e.version);if(!this.cardMap.has(t)){const s=this.cardMap.size;this.cardMap.set(t,s),this.indexMap.set(s,e)}}))),this.cards}async loadModel(e){await this.loadCards();try{const e=await fetch("training_data/vocabulary.json");if(e.ok){const t=await e.json();this.textEmbedder.load(t)}else console.error("Failed to load vocabulary.json")}catch(e){console.error("Error loading vocabulary:",e)}await this.model.loadModel(e)}async predict(e,t=!0,s=[]){const a=[],n=[],i=[];let o=this.getInitialDeckStats();e.forEach((e=>{let t=null;if(e.includes(" - ")){const s=e.split(" - "),a=s[0].trim(),n=s.slice(1).join(" - ").trim(),i=this.getCardKey(a,n);this.cardMap.has(i)&&(t=this.cardMap.get(i))}if(null===t){const s=e.trim().toLowerCase();for(const[e,a]of this.cardMap.entries())if(e.toLowerCase().startsWith(s)){t=a;break}}if(null!==t){a.push(t);const e=this.indexMap.get(t);this.updateDeckStats(o,e);const s=a.filter((e=>e===t)).length-1,r=this.extractCardFeatures(e,o,s),l=this.textEmbedder.cardToTextIndices(e);n.push(r),i.push(l)}}));const r=new Map,l=new Set;a.forEach((e=>{r.set(e,(r.get(e)||0)+1);const t=this.indexMap.get(e);t&&t.ink&&l.add(t.ink)}));const h=await this.model.predict(a,n,i),d=this.boostSingletons(h,a,2.5),c=this.getAdaptiveTemperature(a.length),m=this.sampleTopP(d,c,.9),u=Array.from(d).map(((e,t)=>({index:t,prob:e}))).sort(((e,t)=>t.prob-e.prob)),p=[m,...u.map((e=>e.index)).filter((e=>e!==m))];for(const e of p){const a=this.indexMap.get(e);if(a&&!(t&&"legal"!==a.legality||(r.get(e)||0)>=(a.maxAmount||4))){if(s.length>0&&!(a.inks||(a.ink?[a.ink]:[])).every((e=>s.includes(e))))continue;if(!(l.size>=2)||l.has(a.ink))return a}}return null}getAdaptiveTemperature(e){return e<=10?2:e<=40?1:.8}boostSingletons(e,t,s=2){const a=Float32Array.from(e),n=new Map;for(const e of t)n.set(e,(n.get(e)||0)+1);for(const[e,t]of n)1===t&&e<a.length&&(a[e]*=s);let i=0;for(let e=0;e<a.length;e++)i+=a[e];if(i>0)for(let e=0;e<a.length;e++)a[e]/=i;return a}sampleTopP(e,t=1,s=.9){const a=Array.from(e).map(((e,s)=>({prob:Math.pow(Math.max(e,1e-10),1/t),index:s}))),n=a.reduce(((e,t)=>e+t.prob),0);a.forEach((e=>e.prob/=n)),a.sort(((e,t)=>t.prob-e.prob));let i=0;const o=[];for(const e of a)if(i+=e.prob,o.push(e),i>=s)break;0===o.length&&o.push(a[0]);const r=o.reduce(((e,t)=>e+t.prob),0),l=Math.random()*r;let h=0;for(const e of o)if(h+=e.prob,l<=h)return e.index;return o[o.length-1].index}getInitialDeckStats(){return{totalCards:0,inkableCount:0,costCounts:[0,0,0,0,0,0,0,0,0,0],inkableCostCounts:[0,0,0,0,0,0,0,0,0,0],typeCounts:{character:0,action:0,item:0,location:0},inkCounts:{Amber:0,Amethyst:0,Emerald:0,Ruby:0,Sapphire:0,Steel:0}}}updateDeckStats(e,t){e.totalCards++,t.inkwell&&e.inkableCount++;let s=Math.max(0,Math.min(t.cost-1,9));if(0===t.cost&&(s=0),e.costCounts[s]++,t.inkwell&&e.inkableCostCounts[s]++,t.ink&&(e.inkCounts[t.ink]||(e.inkCounts[t.ink]=0),e.inkCounts[t.ink]++),t.type){const s=t.type.toLowerCase();void 0!==e.typeCounts[s]&&e.typeCounts[s]++}}extractCardFeatures(e,t,s=0){const a=[];a.push(Math.min(e.cost,10)/10),a.push(e.inkwell?1:0),a.push(Math.min(e.lore||0,5)/5),a.push(Math.min(e.strength||0,10)/10),a.push(Math.min(e.willpower||0,10)/10),["Amber","Amethyst","Emerald","Ruby","Sapphire","Steel"].forEach((t=>{a.push(e.ink===t?1:0)}));const n=e.types&&e.types.length>0?e.types[0]:"";["Character","Action","Item","Location"].forEach((e=>{a.push(n===e?1:0)})),["Bodyguard","Reckless","Rush","Ward","Evasive","Resist","Challenger","Singer","Shift","Boost"].forEach((t=>{const s=`has${t}`;if(void 0!==e[s])a.push(e[s]?1:0);else{const s=e.keywords&&e.keywords.some((e=>e.includes(t)));a.push(s?1:0)}})),a.push(Math.min(e.resistAmount||0,10)/10),a.push(Math.min(e.challengerAmount||0,10)/10),a.push(Math.min(e.boostAmount||0,10)/10),a.push(Math.min(e.moveCost||0,10)/10),["Hero","Villain","Dreamborn","Storyborn","Floodborn"].forEach((t=>{a.push(e.classifications&&e.classifications.includes(t)?1:0)})),a.push(Math.min(s,4)/4);const i=Math.max(1,t.totalCards);return a.push(t.inkableCount/i),t.costCounts.forEach((e=>{a.push(e/i)})),Object.values(t.typeCounts).forEach((e=>{a.push(e/i)})),["Amber","Amethyst","Emerald","Ruby","Sapphire","Steel"].forEach((e=>{a.push((t.inkCounts[e]||0)/i)})),t.inkableCostCounts.forEach((e=>{a.push(e/i)})),a}getCardByName(e){let t=null;if(e.includes(" - ")){const s=e.split(" - "),a=s[0].trim(),n=s.slice(1).join(" - ").trim(),i=this.getCardKey(a,n);this.cardMap.has(i)&&(t=this.cardMap.get(i))}if(null===t){const s=e.trim().toLowerCase();for(const[e,a]of this.cardMap.entries())if(e.toLowerCase().startsWith(s)){t=a;break}}return null!==t?this.indexMap.get(t):null}async loadValidationModel(e){try{await this.validationModel.loadModel(e),this.validationModelLoaded=!0,console.log("Validation model loaded successfully")}catch(e){console.error("Failed to load validation model:",e),this.validationModelLoaded=!1}}extractDeckFeatures(e){const t=[],s=[];e.forEach((e=>{const t=this.getCardKey(e.name,e.version);this.cardMap.has(t)&&s.push(this.cardMap.get(t))}));const a=[0,0,0,0,0],n=new Map;for(const e of s)n.set(e,(n.get(e)||0)+1);for(const e of n.values())1===e?a[0]++:2===e?a[1]++:3===e?a[2]++:4===e?a[3]++:a[4]++;const i=[...n.keys()].length;a.forEach(((e,s)=>t.push(e/Math.max(1,i))));const o=Array(10).fill(0);let r=0,l=s.length;const h={character:0,action:0,item:0,location:0},d={Amber:0,Amethyst:0,Emerald:0,Ruby:0,Sapphire:0,Steel:0},c={Ward:0,Evasive:0,Bodyguard:0,Resist:0,Singer:0,Shift:0,Reckless:0,Challenger:0,Rush:0},m=new Map;for(const e of s){const t=this.indexMap.get(e);if(t){if(o[Math.min(t.cost-1,9)]++,t.inkwell&&r++,t.types&&t.types.length>0){const e=t.types[0].toLowerCase();void 0!==h[e]&&h[e]++}t.ink&&void 0!==d[t.ink]&&d[t.ink]++;for(const e of Object.keys(c))(t[`has${e}`]||t.keywords&&t.keywords.some((t=>t.includes(e))))&&c[e]++;if(t.classifications)for(const e of t.classifications)m.set(e,(m.get(e)||0)+1)}}o.forEach((e=>t.push(e/l))),Object.values(h).forEach((e=>t.push(e/l))),Object.values(d).forEach((e=>t.push(e/l))),t.push(r/l),Object.values(c).forEach((e=>t.push(e/l))),t.push(m.size/10);const u=m.size>0?Array.from(m.values()).reduce(((e,t)=>e+t),0)/m.size/l:0;return t.push(u),t}async validateDeck(e){if(!this.validationModelLoaded)return console.warn("Validation model not loaded"),null;if(!e||e.length<60)return{score:0,grade:"D",message:"Deck must have 60 cards",breakdown:[]};const t=this.extractDeckFeatures(e);return await this.validationModel.evaluateWithBreakdown(t)}}var h=s(238),d=s(795),c=s(814),m=s(479),u=s(844);document.addEventListener("DOMContentLoaded",(async()=>{const e=new l,t=document.getElementById("generate-deck-btn"),s=document.getElementById("test-deck-btn"),a=document.getElementById("clear-deck-btn"),n=document.querySelector('[data-role="chart"]'),i=document.getElementById("legal-only"),o=new h.A(n);let r,p,k,y,x=[],g=[];y=new u.A;const f=document.querySelector('[data-role="deck"]');p=new c.A(f,{onRemove:e=>{const t=x.findIndex((t=>t.id===e));-1!==t&&(x.splice(t,1),v(),r.refresh())},onAdd:()=>r.show(),onCardClick:e=>y.show(e.image,e.name),isEditable:!0,showAddPlaceholder:!0}),k=new m.A(document.querySelector('[data-role="ink-selector"]'),{onChange:e=>{g=e;const t=x.filter((e=>g.includes(e.ink)||T(e,g)));t.length!==x.length&&(x=t,v()),r&&r.refresh()}}),v();try{console.log("Loading AI model..."),await e.loadModel("training_data/deck-generator-model/model.json"),console.log("Model loaded successfully!"),r=new d.A(e.cards,document.querySelector("[data-role=card-select]"),(e=>function(e){if(x.length>=60)return void alert("Deck is full (60 cards).");x.filter((t=>t.title===e.title)).length>=e.maxAmount?alert(`Cannot add more than ${e.maxAmount} copies of this card.`):(x.push(e),v(),r.refresh())}(e)),{filter:e=>!(g.length>0&&!g.includes(e.ink)&&!T(e,g))&&x.filter((t=>t.title===e.title)).length<e.maxAmount,renderButtonText:e=>{const t=x.filter((t=>t.title===e.title)).length;return t>=e.maxAmount?`Max Reached <small>(${t}/${e.maxAmount})</small>`:`Add Card (${t}/${e.maxAmount})`}}),t.disabled=!1;try{console.log("Loading validation model..."),await e.loadValidationModel("training_data/deck-validator-model/model.json"),console.log("Validation model loaded!")}catch(e){console.warn("Validation model not available:",e)}}catch(e){console.error("Failed to load model:",e),alert("Failed to load AI model. Please refresh the page.")}function T(e,t){return!(2!==t.length||!e.inks)&&t.includes(e.inks[0])&&t.includes(e.inks[1])}function v(){p.render(x,g),s.classList.remove("hidden"),x.length<60&&s.classList.add("hidden"),x.length>0?o.renderChart(x):o.renderChart([]),async function(){const t=document.querySelector('[data-role="validation-score"]');if(!t)return;if(x.length<60)return void(t.innerHTML=`\n                <div class="validation-card">\n                    <div class="validation-header">\n                        <h3>Deck Realism</h3>\n                        <span class="validation-grade grade-empty">-</span>\n                    </div>\n                    <div class="validation-message">Add ${60-x.length} more cards</div>\n                </div>\n            `);const s=await e.validateDeck(x);if(!s)return void(t.innerHTML="");const a=Math.round(100*s.score),n="A"===s.grade?"grade-a":"B"===s.grade?"grade-b":"C"===s.grade?"grade-c":"grade-d";let i="";s.breakdown&&s.breakdown.length>0&&(i='<div class="validation-breakdown">',i+="<h4>Issues Detected:</h4>",i+="<ul>",s.breakdown.forEach((e=>{const t="high"===e.severity?"severity-high":"severity-medium";i+=`<li class="${t}"><strong>${e.issue}:</strong> ${e.message}</li>`})),i+="</ul></div>"),t.innerHTML=`\n            <div class="validation-card">\n                <div class="validation-header">\n                    <h3>Deck Realism</h3>\n                    <span class="validation-grade ${n}">${s.grade}</span>\n                </div>\n                <div class="validation-score"\n>${a}%</div>\n                <div class="validation-message">${s.message}</div>\n                ${i}\n            </div>\n        `}()}t.addEventListener("click",(async()=>{t.disabled=!0;const s=i.checked;for(;x.length<60;){const t=x.map((e=>e.version?`${e.name} - ${e.version}`:e.name)),a=await e.predict(t,s,g);if(!a||"string"==typeof a){console.warn("No valid prediction:",a);break}x.push(a),v(),await new Promise((e=>setTimeout(e,10)))}t.disabled=!1})),a.addEventListener("click",(()=>{x=[],v(),s.classList.add("hidden")})),s.addEventListener("click",(()=>{window.open(function(){const e=Math.random().toString(36).substring(7);let t=`AI Generated Deck: ${g[0]} - ${g[1]} - ${e}`;t=encodeURIComponent(t);let s="";const a=[...new Set(x.map((e=>e.title)))];for(const e of a){const t=x.filter((t=>t.title===e)).length;s+=`${e}$${t}|`}return`https://inktable.net/lor/import?svc=dreamborn&name=${t}&id=${btoa(s)}`}(),"_blank")}))}))},817:()=>{},590:()=>{},530:()=>{},108:()=>{},551:()=>{},234:()=>{}},e=>{e.O(0,[839,122,452],(()=>e(e.s=580))),e.O()}]);